<html><!-- Mirrored from developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Connectivity by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 14 Feb 2023 04:49:46 GMT --><!-- Added by HTTrack --><head><meta http-equiv="content-type" content="text/html;charset=utf-8"><!-- /Added by HTTrack -->
<meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="icon" href="../../../../../favicon-48x48.cbbd161b.png"><link rel="apple-touch-icon" href="../../../../../apple-touch-icon.6803c6f0.png"><meta name="theme-color" content="#ffffff"><link rel="manifest" href="../../../../../manifest.56b1cedc.json"><link rel="search" type="application/opensearchdescription+xml" href="https://developer.mozilla.org/opensearch.xml" title="MDN Web Docs"><title>WebRTC connectivity</title><link rel="alternate" title="Introduction à l'architecture WebRTC" href="https://developer.mozilla.org/fr/docs/Web/API/WebRTC_API/Connectivity" hreflang="fr"><link rel="alternate" title="WebRTC 接続" href="https://developer.mozilla.org/ja/docs/Web/API/WebRTC_API/Connectivity" hreflang="ja"><link rel="alternate" title="WebRTC подключение" href="https://developer.mozilla.org/ru/docs/Web/API/WebRTC_API/Connectivity" hreflang="ru"><link rel="alternate" title="WebRTC connectivity" href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebRTC_API/Connectivity" hreflang="zh"><link rel="alternate" title="WebRTC connectivity" href="Connectivity.html" hreflang="en"><meta name="robots" content="index, follow"><meta name="description" content="This article describes how the various WebRTC-related protocols interact with one another in order to create a connection and transfer data and/or media among peers."><meta property="og:url" content="Connectivity.html"><meta property="og:title" content="WebRTC connectivity - Web APIs | MDN"><meta property="og:locale" content="en-US"><meta property="og:description" content="This article describes how the various WebRTC-related protocols interact with one another in order to create a connection and transfer data and/or media among peers."><meta property="og:image" content="../../../../../mdn-social-share.cd6c4a5a.png"><meta property="twitter:card" content="summary_large_image"><link rel="canonical" href="Connectivity.html"><style media="print">.article-actions-container,.document-toc-container,.language-menu,.main-menu-toggle,.mdn-cta-container,.on-github,.page-footer,.sidebar,.top-navigation-main,ul.prev-next{display:none!important}.main-page-content,.main-page-content pre{padding:2px}.main-page-content pre{border-left-width:2px}</style><script src="../../../../../static/js/ga.js" defer=""></script><script defer="defer" src="../../../../../static/js/main.5c9d40d0.js"></script><link href="../../../../../static/css/main.7d378400.css" rel="stylesheet"></head><body><script>document.body.addEventListener("load",(t=>{t.target.classList.contains("interactive")&&t.target.setAttribute("data-readystate","complete")}),{capture:!0});const c={light:"#ffffff",dark:"#1b1b1b"};if(window&&document.documentElement)try{const t=window.localStorage.getItem("theme");t&&(document.documentElement.className=t,document.documentElement.style.backgroundColor=c[t])}catch(t){console.warn("Unable to read theme from localStorage",t)}</script><div id="root"><ul id="nav-access" class="a11y-nav"><li><a id="skip-main" href="#content">Skip to main content</a></li><li><a id="skip-search" href="#top-nav-search-input">Skip to search</a></li><li><a id="skip-select-language" href="#languages-switcher-button">Skip to select language</a></li></ul><div class="page-wrapper  category-api document-page"><div class="main-document-header-container"><header class="main-document-header-container top-navigation 
      
      "><div class="container "><div class="top-navigation-wrap"><a href="https://developer.mozilla.org/en-US/" class="logo" aria-label="MDN homepage"><svg id="mdn-docs-logo" xmlns="http://www.w3.org/2000/svg" x="0" y="0" viewBox="0 0 694.9 104.4" style="enable-background:new 0 0 694.9 104.4" xml:space="preserve" role="img"><title>MDN Web Docs</title><style>.logo-m{fill:var(--text-link)}</style><g class="logo-m"><path d="M40.3 0 11.7 92.1H0L28.5 0h11.8zM50.7 0v92.1H40.3V0h10.4zM91 0 62.5 92.1H50.8L79.3 0H91zM101.4 0v92.1H91V0h10.4z"></path></g><path class="logo-m" d="M627.9 95.6h67v8.8h-67v-8.8z"></path><g style="fill:var(--text-primary)"><path d="M367 42h-4l-10.7 30.8h-5.5l-10.8-26h-.4l-10.5 26h-5.2L308.7 42h-3.8v-5.6H323V42h-6.5l6.8 20.4h.4l10.3-26h4.7l11.2 26h.5l5.7-20.3h-6.2v-5.6H367V42zM401.9 62c-.4 3.2-2 5.9-4.7 8.2-2.8 2.3-6.5 3.4-11.3 3.4-5.4 0-9.7-1.6-13.1-4.7-3.3-3.2-5-7.7-5-13.7 0-5.7 1.6-10.3 4.7-14s7.4-5.5 12.9-5.5c5.1 0 9.1 1.6 11.9 4.7s4.3 6.9 4.3 11.3c0 1.5-.2 3-.5 4.7h-25.6c.3 7.7 4 11.6 10.9 11.6 2.9 0 5.1-.7 6.5-2 1.5-1.4 2.5-3 3-4.9l6 .9zM394 51.3c.2-2.4-.4-4.7-1.8-6.9s-3.8-3.3-7-3.3c-3.1 0-5.3 1-6.9 3-1.5 2-2.5 4.4-2.8 7.2H394zM445 53.7c0 5-1.3 9.5-4 13.7s-6.9 6.2-12.7 6.2c-6 0-10.3-2.2-12.7-6.7-.1.4-.2 1.4-.4 2.9s-.3 2.5-.4 2.9h-7.3c.3-1.7.6-3.5.8-5.3.3-1.8.4-3.7.4-5.5V22.3h-6v-5.6H416v27c1.1-2.2 2.7-4.1 4.7-5.7 2-1.6 4.8-2.4 8.4-2.4 4.6 0 8.4 1.6 11.4 4.7 3 3.2 4.5 7.6 4.5 13.4zm-7.7.6c0-4.2-1-7.4-3-9.5-2-2.2-4.4-3.3-7.4-3.3-3.4 0-6 1.2-8 3.7-1.9 2.4-2.9 5-3 7.7V57c0 3 1 5.6 3 7.7s4.5 3.1 7.6 3.1c3.6 0 6.3-1.3 8.1-3.9 1.8-2.7 2.7-5.9 2.7-9.6zM506.5 72.8h-13.2v-7.2c-1.2 2.2-2.8 4.1-4.9 5.6-2.1 1.6-4.8 2.4-8.3 2.4-4.8 0-8.7-1.6-11.6-4.9-2.9-3.2-4.3-7.7-4.3-13.3 0-5 1.3-9.6 4-13.7 2.6-4.1 6.9-6.2 12.8-6.2 5.7 0 9.8 2.2 12.3 6.5V22.3h-8.6v-5.6h15.8v50.6h6v5.5zM493.2 56v-4.4c-.1-3-1.2-5.5-3.2-7.3s-4.4-2.8-7.2-2.8c-3.6 0-6.3 1.3-8.2 3.9-1.9 2.6-2.8 5.8-2.8 9.6 0 4.1 1 7.3 3 9.5s4.5 3.3 7.4 3.3c3.2 0 5.8-1.3 7.8-3.8 2.1-2.6 3.1-5.3 3.2-8zM546.3 54.6c0 5.6-1.8 10.2-5.3 13.7s-8.2 5.3-13.9 5.3-10.1-1.7-13.4-5.1c-3.3-3.4-5-7.9-5-13.5 0-5.3 1.6-9.9 4.7-13.7 3.2-3.8 7.9-5.7 14.2-5.7s11 1.9 14.1 5.7c3 3.7 4.6 8.1 4.6 13.3zm-7.7-.2c0-4-1-7.2-3-9.5s-4.8-3.5-8.2-3.5c-3.6 0-6.4 1.2-8.3 3.7s-2.9 5.6-2.9 9.5c0 3.7.9 6.8 2.8 9.4 1.9 2.6 4.6 3.9 8.3 3.9 3.6 0 6.4-1.3 8.4-3.8 1.9-2.6 2.9-5.8 2.9-9.7zM583.6 60.2c-.4 3.2-1.9 6.3-4.4 9.1-2.5 2.9-6.4 4.3-11.8 4.3-5.2 0-9.4-1.6-12.6-4.8-3.2-3.2-4.8-7.7-4.8-13.7 0-5.5 1.6-10.1 4.7-13.9 3.2-3.8 7.6-5.7 13.2-5.7 2.3 0 4.6.3 6.7.8 2.2.5 4.2 1.5 6.2 2.9l1.5 9.5-5.9.7-1.3-6.1c-2.1-1.2-4.5-1.8-7.2-1.8-3.5 0-6.1 1.2-7.7 3.7-1.7 2.5-2.5 5.7-2.5 9.6 0 4.1.9 7.3 2.7 9.5 1.8 2.3 4.4 3.4 7.8 3.4 5.2 0 8.2-2.9 9.2-8.8l6.2 1.3zM618.3 62.1c0 3.6-1.5 6.5-4.6 8.5s-7 3-11.7 3c-5.7 0-10.6-1.2-14.6-3.6l1.2-8.8 5.7.6-.2 4.7c1.1.5 2.3.9 3.6 1.1s2.6.3 3.9.3c2.4 0 4.5-.4 6.5-1.3 1.9-.9 2.9-2.2 2.9-4.1 0-1.8-.8-3.1-2.3-3.8s-3.5-1.3-5.8-1.7-4.6-.9-6.9-1.4c-2.3-.6-4.2-1.6-5.7-2.9-1.6-1.4-2.3-3.5-2.3-6.3 0-4.1 1.5-6.9 4.6-8.5s6.4-2.4 9.9-2.4c2.6 0 5 .3 7.2.9 2.2.6 4.3 1.4 6.1 2.4l.8 8.8-5.8.7-.8-5.7c-2.3-1-4.7-1.6-7.2-1.6-2.1 0-3.7.4-5.1 1.1-1.3.8-2 2-2 3.8 0 1.7.8 2.9 2.3 3.6 1.5.7 3.4 1.2 5.7 1.6 2.2.4 4.5.8 6.7 1.4 2.2.6 4.1 1.6 5.7 3 1.4 1.6 2.2 3.7 2.2 6.6zM197.6 73.2h-17.1v-5.5h3.8V51.9c0-3.7-.7-6.3-2.1-7.9-1.4-1.6-3.3-2.3-5.7-2.3-3.2 0-5.6 1.1-7.2 3.4s-2.4 4.6-2.5 6.9v15.6h6v5.5h-17.1v-5.5h3.8V51.9c0-3.8-.7-6.4-2.1-7.9-1.4-1.5-3.3-2.3-5.6-2.3-3.2 0-5.5 1.1-7.2 3.3-1.6 2.2-2.4 4.5-2.5 6.9v15.8h6.9v5.5h-20.2v-5.5h6V42.4h-6.1v-5.6h13.4v6.4c1.2-2.1 2.7-3.8 4.7-5.2 2-1.3 4.4-2 7.3-2s5.3.7 7.5 2.1c2.2 1.4 3.7 3.5 4.5 6.4 1.1-2.5 2.7-4.5 4.9-6.1s4.8-2.4 7.9-2.4c3.5 0 6.5 1.1 8.9 3.3s3.7 5.6 3.7 10.2v18.2h6.1v5.5zm42.5 0h-13.2V66c-1.2 2.2-2.8 4.1-4.9 5.6-2.1 1.6-4.8 2.4-8.3 2.4-4.8 0-8.7-1.6-11.6-4.9-2.9-3.2-4.3-7.7-4.3-13.3 0-5 1.3-9.6 4-13.7 2.6-4.1 6.9-6.2 12.8-6.2s9.8 2.2 12.3 6.5V22.7h-8.6v-5.6h15.8v50.6h6v5.5zm-13.3-16.8V52c-.1-3-1.2-5.5-3.2-7.3s-4.4-2.8-7.2-2.8c-3.6 0-6.3 1.3-8.2 3.9-1.9 2.6-2.8 5.8-2.8 9.6 0 4.1 1 7.3 3 9.5s4.5 3.3 7.4 3.3c3.2 0 5.8-1.3 7.8-3.8 2.1-2.6 3.1-5.3 3.2-8zm61.5 16.8H269v-5.5h6V51.9c0-3.7-.7-6.3-2.2-7.9-1.4-1.6-3.4-2.3-5.7-2.3-3.1 0-5.6 1-7.4 3s-2.8 4.4-2.9 7v15.9h6v5.5h-19.3v-5.5h6V42.4h-6.2v-5.6h13.6V43c2.6-4.6 6.8-6.9 12.7-6.9 3.6 0 6.7 1.1 9.2 3.3s3.7 5.6 3.7 10.2v18.2h6v5.4h-.2z"></path></g></svg></a><button title="Open main menu" type="button" class="button action has-icon main-menu-toggle" aria-haspopup="menu" aria-label="Open main menu" aria-expanded="false"><span class="button-wrap"><span class="icon icon-menu "></span><span class="visually-hidden">Open main menu</span></span></button></div><div class="top-navigation-main"><nav class="main-nav" aria-label="Main menu"><ul class="main-menu nojs"><li class="top-level-entry-container"><button type="button" id="references-button" class="top-level-entry menu-toggle" aria-controls="references-menu" aria-expanded="false">References</button><a href="https://developer.mozilla.org/en-US/docs/Web" class="top-level-entry">References</a><ul id="references-menu" class="submenu references hidden inline-submenu-lg" aria-labelledby="references-button"><li class="apis-link-container mobile-only "><a href="https://developer.mozilla.org/en-US/docs/Web" class="submenu-item "><div class="submenu-icon"></div><div class="submenu-content-container"><div class="submenu-item-heading">Overview / Web Technology</div><p class="submenu-item-description">Web technology reference for developers</p></div></a></li><li class="html-link-container "><a href="https://developer.mozilla.org/en-US/docs/Web/HTML" class="submenu-item "><div class="submenu-icon html"></div><div class="submenu-content-container"><div class="submenu-item-heading">HTML</div><p class="submenu-item-description">Structure of content on the web</p></div></a></li><li class="css-link-container "><a href="https://developer.mozilla.org/en-US/docs/Web/CSS" class="submenu-item "><div class="submenu-icon css"></div><div class="submenu-content-container"><div class="submenu-item-heading">CSS</div><p class="submenu-item-description">Code used to describe document style</p></div></a></li><li class="javascript-link-container "><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript" class="submenu-item "><div class="submenu-icon javascript"></div><div class="submenu-content-container"><div class="submenu-item-heading">JavaScript</div><p class="submenu-item-description">General-purpose scripting language</p></div></a></li><li class="http-link-container "><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP" class="submenu-item "><div class="submenu-icon http"></div><div class="submenu-content-container"><div class="submenu-item-heading">HTTP</div><p class="submenu-item-description">Protocol for transmitting web resources</p></div></a></li><li class="apis-link-container "><a href="../../API.html" class="submenu-item "><div class="submenu-icon apis"></div><div class="submenu-content-container"><div class="submenu-item-heading">Web APIs</div><p class="submenu-item-description">Interfaces for building web applications</p></div></a></li><li class="apis-link-container "><a href="https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions" class="submenu-item "><div class="submenu-icon"></div><div class="submenu-content-container"><div class="submenu-item-heading">Web Extensions</div><p class="submenu-item-description">Developing extensions for web browsers</p></div></a></li><li class="apis-link-container desktop-only "><a href="https://developer.mozilla.org/en-US/docs/Web" class="submenu-item "><div class="submenu-icon"></div><div class="submenu-content-container"><div class="submenu-item-heading">Web Technology</div><p class="submenu-item-description">Web technology reference for developers</p></div></a></li></ul></li><li class="top-level-entry-container"><button type="button" id="guides-button" class="top-level-entry menu-toggle" aria-controls="guides-menu" aria-expanded="false">Guides</button><a href="https://developer.mozilla.org/en-US/docs/Learn" class="top-level-entry">Guides</a><ul id="guides-menu" class="submenu guides hidden inline-submenu-lg" aria-labelledby="guides-button"><li class="apis-link-container mobile-only "><a href="https://developer.mozilla.org/en-US/docs/Learn" class="submenu-item "><div class="submenu-icon learn"></div><div class="submenu-content-container"><div class="submenu-item-heading">Overview / MDN Learning Area</div><p class="submenu-item-description">Learn web development</p></div></a></li><li class="apis-link-container desktop-only "><a href="https://developer.mozilla.org/en-US/docs/Learn" class="submenu-item "><div class="submenu-icon learn"></div><div class="submenu-content-container"><div class="submenu-item-heading">MDN Learning Area</div><p class="submenu-item-description">Learn web development</p></div></a></li><li class="html-link-container "><a href="https://developer.mozilla.org/en-US/docs/Learn/HTML" class="submenu-item "><div class="submenu-icon html"></div><div class="submenu-content-container"><div class="submenu-item-heading">HTML</div><p class="submenu-item-description">Learn to structure web content with HTML</p></div></a></li><li class="css-link-container "><a href="https://developer.mozilla.org/en-US/docs/Learn/CSS" class="submenu-item "><div class="submenu-icon css"></div><div class="submenu-content-container"><div class="submenu-item-heading">CSS</div><p class="submenu-item-description">Learn to style content using CSS</p></div></a></li><li class="javascript-link-container "><a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript" class="submenu-item "><div class="submenu-icon javascript"></div><div class="submenu-content-container"><div class="submenu-item-heading">JavaScript</div><p class="submenu-item-description">Learn to run scripts in the browser</p></div></a></li><li class=" "><a href="https://developer.mozilla.org/en-US/docs/Web/Accessibility" class="submenu-item "><div class="submenu-icon"></div><div class="submenu-content-container"><div class="submenu-item-heading">Accessibility</div><p class="submenu-item-description">Learn to make the web accessible to all</p></div></a></li></ul></li><li class="top-level-entry-container"><button type="button" id="mdn-plus-button" class="top-level-entry menu-toggle" aria-controls="mdn-plus-menu" aria-expanded="false">MDN Plus</button><a href="https://developer.mozilla.org/en-US/plus" class="top-level-entry">MDN Plus</a><ul id="mdn-plus-menu" class="submenu mdn-plus hidden inline-submenu-lg" aria-labelledby="mdn-plus-button"><li class=" "><a href="https://developer.mozilla.org/en-US/plus" class="submenu-item "><div class="submenu-icon"></div><div class="submenu-content-container"><div class="submenu-item-heading">Overview</div><p class="submenu-item-description">A customized MDN experience</p></div></a></li><li class=" "><a href="https://developer.mozilla.org/en-US/plus/updates" class="submenu-item "><div class="submenu-icon"></div><div class="submenu-content-container"><div class="submenu-item-heading">Updates</div><p class="submenu-item-description">All browser compatibility updates at a glance</p></div></a></li><li class=" "><a href="https://developer.mozilla.org/en-US/plus/docs/features/overview" class="submenu-item "><div class="submenu-icon"></div><div class="submenu-content-container"><div class="submenu-item-heading">Documentation</div><p class="submenu-item-description">Learn how to use MDN Plus</p></div></a></li><li class=" "><a href="https://developer.mozilla.org/en-US/plus/docs/faq" class="submenu-item "><div class="submenu-icon"></div><div class="submenu-content-container"><div class="submenu-item-heading">FAQ</div><p class="submenu-item-description">Frequently asked questions about MDN Plus</p></div></a></li></ul></li></ul></nav><div class="header-search"><form action="https://developer.mozilla.org/en-US/search" role="search" aria-haspopup="listbox" aria-owns="top-nav-search-menu" aria-expanded="false" class="search-form search-widget" id="top-nav-search-form"><label id="top-nav-search-label" for="top-nav-search-input" class="visually-hidden">Search MDN</label><input id="top-nav-search-input" aria-autocomplete="list" aria-controls="top-nav-search-menu" aria-labelledby="top-nav-search-label" autocomplete="off" type="search" class="search-input-field" name="q" placeholder="   " required="" value=""><button type="button" class="button action has-icon clear-search-button"><span class="button-wrap"><span class="icon icon-cancel "></span><span class="visually-hidden">Clear search input</span></span></button><button type="submit" class="button action has-icon search-button"><span class="button-wrap"><span class="icon icon-search "></span><span class="visually-hidden">Search</span></span></button><div id="top-nav-search-menu" role="listbox" aria-labelledby="top-nav-search-label"></div></form></div><div class="theme-switcher-menu"><button type="button" class="button action has-icon theme-switcher-menu small" aria-haspopup="menu"><span class="button-wrap"><span class="icon icon-theme-os-default "></span>Theme</span></button></div><ul class="auth-container"><li><a href="https://developer.mozilla.org/users/fxa/login/authenticate/?next=%2Fen-US%2Fdocs%2FWeb%2FAPI%2FWebRTC_API%2FConnectivity" class="signin-link" rel="nofollow">Already a subscriber?</a></li><li><a class="button primary mdn-plus-subscribe-link" href="https://developer.mozilla.org/en-US/plus"><span class="button-wrap">Get MDN Plus</span></a></li></ul></div></div></header><div class="article-actions-container"><div class="container"><button type="button" class="button action has-icon sidebar-button" aria-label="Expand sidebar" aria-expanded="false" aria-controls="sidebar-quicklinks"><span class="button-wrap"><span class="icon icon-sidebar "></span></span></button><nav class="breadcrumbs-container" aria-label="Breadcrumb"><ol typeof="BreadcrumbList" vocab="https://schema.org/" aria-label="breadcrumbs"><li property="itemListElement" typeof="ListItem"><a class="breadcrumb" property="item" typeof="WebPage" href="https://developer.mozilla.org/en-US/docs/Web"><span property="name">References</span></a><meta property="position" content="1"></li><li property="itemListElement" typeof="ListItem"><a class="breadcrumb" property="item" typeof="WebPage" href="../../API.html"><span property="name">Web APIs</span></a><meta property="position" content="2"></li><li property="itemListElement" typeof="ListItem"><a class="breadcrumb" property="item" typeof="WebPage" href="../WebRTC_API.html"><span property="name">WebRTC API</span></a><meta property="position" content="3"></li><li property="itemListElement" typeof="ListItem"><a class="breadcrumb-current-page" property="item" typeof="WebPage" href="Connectivity.html"><span property="name">WebRTC connectivity</span></a><meta property="position" content="4"></li></ol></nav><div class="article-actions"><button type="button" class="button action has-icon article-actions-toggle" aria-label="Article actions"><span class="button-wrap"><span class="icon icon-ellipses "></span><span class="article-actions-dialog-heading">Article Actions</span></span></button><ul class="article-actions-entries"><li class="article-actions-entry"><div class="languages-switcher-menu open-on-focus-within"><button id="languages-switcher-button" type="button" class="button action small has-icon languages-switcher-menu" aria-haspopup="menu"><span class="button-wrap"><span class="icon icon-language "></span>English (US)</span></button></div></li></ul></div></div></div></div><div class="main-wrapper"><aside id="sidebar-quicklinks" class="sidebar"><button type="button" class="button action backdrop" aria-label="Collapse sidebar"><span class="button-wrap"></span></button><nav aria-label="Related Topics" class="sidebar-inner"><div class="in-nav-toc"><div class="document-toc-container"><section class="document-toc"><header><h2 class="document-toc-heading">In this article</h2></header><ul class="document-toc-list"><li class="document-toc-item "><a class="document-toc-link" href="#signaling">Signaling</a></li><li class="document-toc-item "><a class="document-toc-link" href="#ice_candidates">ICE candidates</a></li><li class="document-toc-item "><a class="document-toc-link" href="#when_things_go_wrong">When things go wrong</a></li><li class="document-toc-item "><a class="document-toc-link" href="#the_entire_exchange_in_a_complicated_diagram">The entire exchange in a complicated diagram</a></li></ul></section></div></div><div><ol><li><strong><a href="../WebRTC_API.html">WebRTC API</a></strong></li><li class="toggle"><details open=""><summary>Guides</summary><ol><li><a href="Protocols.html">Introduction to WebRTC protocols</a></li><li><em><a href="Connectivity.html" aria-current="page">WebRTC connectivity</a></em></li><li><a href="Session_lifetime.html">Lifetime of a WebRTC session</a></li><li><a href="Signaling_and_video_calling.html">Signaling and video calling</a></li><li><a href="Using_data_channels.html">Using WebRTC data channels</a></li><li><a href="Using_DTMF.html">Using DTMF with WebRTC</a></li><li><a href="../WebRTC_API.html#interoperability">WebRTC API</a></li><li><a href="Simple_RTCDataChannel_sample.html">A simple RTCDataChannel sample</a></li><li><a href="Build_a_phone_with_peerjs.html">Building an Internet-Connected Phone with PeerJS</a></li></ol></details></li><li class="toggle"><details open=""><summary>Interfaces</summary><ol><li><a href="../RTCPeerConnection.html"><code>RTCPeerConnection</code></a></li><li><a href="../RTCSessionDescription.html"><code>RTCSessionDescription</code></a></li><li><a href="../RTCIceCandidate.html"><code>RTCIceCandidate</code></a></li><li><a href="../RTCPeerConnectionIceEvent.html"><code>RTCPeerConnectionIceEvent</code></a></li><li><a href="../RTCPeerConnectionIceErrorEvent.html"><code>RTCPeerConnectionIceErrorEvent</code></a></li><li><a href="../RTCCertificate.html"><code>RTCCertificate</code></a></li><li><a href="../RTCRtpSender.html"><code>RTCRtpSender</code></a></li><li><a href="../RTCRtpReceiver.html"><code>RTCRtpReceiver</code></a></li><li><a href="../RTCRtpTransceiver.html"><code>RTCRtpTransceiver</code></a></li><li><a href="../RTCDtlsTransport.html"><code>RTCDtlsTransport</code></a></li><li><a href="../RTCIceTransport.html"><code>RTCIceTransport</code></a></li><li><a href="../RTCTrackEvent.html"><code>RTCTrackEvent</code></a></li><li><a href="../RTCSctpTransport.html"><code>RTCSctpTransport</code></a></li><li><a href="../RTCDataChannel.html"><code>RTCDataChannel</code></a></li><li><a href="../RTCDataChannelEvent.html"><code>RTCDataChannelEvent</code></a></li><li><a href="../RTCDTMFSender.html"><code>RTCDTMFSender</code></a></li><li><a href="../RTCDTMFToneChangeEvent.html"><code>RTCDTMFToneChangeEvent</code></a></li><li><a href="../RTCStatsReport.html"><code>RTCStatsReport</code></a></li><li><a href="../RTCErrorEvent.html"><code>RTCErrorEvent</code></a></li></ol></details></li><li class="toggle"><details open=""><summary>Properties</summary><ol><li><a href="../Navigator/mediaDevices.html"><code>Navigator.mediaDevices</code></a></li></ol></details></li><li class="toggle"><details open=""><summary>Methods</summary><ol><li><a href="../MediaDevices/getUserMedia.html"><code>MediaDevices.getUserMedia()</code></a></li></ol></details></li><li class="toggle"><details open=""><summary>Events</summary><ol><li><a href="../RTCDTMFSender/tonechange_event.html"><code>RTCDTMFSender</code>: <code>tonechange</code></a></li><li><a href="../RTCDataChannel/bufferedamountlow_event.html"><code>RTCDataChannel</code>: <code>bufferedamountlow</code></a></li><li><a href="../RTCDataChannel/close_event.html"><code>RTCDataChannel</code>: <code>close</code></a></li><li><a href="../RTCDataChannel/closing_event.html"><code>RTCDataChannel</code>: <code>closing</code></a></li><li><a href="../RTCDataChannel/error_event.html"><code>RTCDataChannel</code>: <code>error</code></a></li><li><a href="../RTCDataChannel/message_event.html"><code>RTCDataChannel</code>: <code>message</code></a></li><li><a href="../RTCDataChannel/open_event.html"><code>RTCDataChannel</code>: <code>open</code></a></li><li><a href="../RTCDtlsTransport/error_event.html"><code>RTCDtlsTransport</code>: <code>error</code></a></li><li><a href="../RTCDtlsTransport/statechange_event.html"><code>RTCDtlsTransport</code>: <code>statechange</code></a></li><li><a href="../RTCIceTransport/error_event.html"><code>RTCIceTransport</code>: <code>error</code></a></li><li><a href="../RTCIceTransport/gatheringstatechange_event.html"><code>RTCIceTransport</code>: <code>gatheringstatechange</code></a></li><li><a href="../RTCIceTransport/selectedcandidatepairchange_event.html"><code>RTCIceTransport</code>: <code>selectedcandidatepairchange</code></a></li><li><a href="../RTCIceTransport/statechange_event.html"><code>RTCIceTransport</code>: <code>statechange</code></a></li><li><a href="../RTCPeerConnection/connectionstatechange_event.html"><code>RTCPeerConnection</code>: <code>connectionstatechange</code></a></li><li><a href="../RTCPeerConnection/datachannel_event.html"><code>RTCPeerConnection</code>: <code>datachannel</code></a></li><li><a href="../RTCPeerConnection/icecandidate_event.html"><code>RTCPeerConnection</code>: <code>icecandidate</code></a></li><li><a href="../RTCPeerConnection/icecandidateerror_event.html"><code>RTCPeerConnection</code>: <code>icecandidateerror</code></a></li><li><a href="../RTCPeerConnection/iceconnectionstatechange_event.html"><code>RTCPeerConnection</code>: <code>iceconnectionstatechange</code></a></li><li><a href="../RTCPeerConnection/icegatheringstatechange_event.html"><code>RTCPeerConnection</code>: <code>icegatheringstatechange</code></a></li><li><a href="../RTCPeerConnection/negotiationneeded_event.html"><code>RTCPeerConnection</code>: <code>negotiationneeded</code></a></li><li><a href="../RTCPeerConnection/signalingstatechange_event.html"><code>RTCPeerConnection</code>: <code>signalingstatechange</code></a></li><li><a href="../RTCPeerConnection/track_event.html"><code>RTCPeerConnection</code>: <code>track</code></a></li><li><a href="../RTCSctpTransport/error_event.html"><code>RTCSctpTransport</code>: <code>error</code></a></li></ol></details></li></ol></div></nav></aside><aside class="toc"><nav><div class="document-toc-container"><section class="document-toc"><header><h2 class="document-toc-heading">In this article</h2></header><ul class="document-toc-list"><li class="document-toc-item "><a class="document-toc-link" href="#signaling">Signaling</a></li><li class="document-toc-item "><a class="document-toc-link" href="#ice_candidates">ICE candidates</a></li><li class="document-toc-item "><a class="document-toc-link" href="#when_things_go_wrong">When things go wrong</a></li><li class="document-toc-item "><a class="document-toc-link" href="#the_entire_exchange_in_a_complicated_diagram">The entire exchange in a complicated diagram</a></li></ul></section></div></nav></aside><main id="content" class="main-content  "><article class="main-page-content" lang="en-US"><h1>WebRTC connectivity</h1><div class="section-content"><p>This article describes how the various WebRTC-related protocols interact with one another in order to create a connection and transfer data and/or media among peers.</p>
<div class="notecard note" id="sect1">
  <p><strong>Note:</strong> This page needs heavy rewriting for structural integrity and content completeness. Lots of info here is good but the organization is a mess since this is sort of a dumping ground right now.</p>
</div></div><section aria-labelledby="signaling"><a class="dashAnchor" name="//apple_ref/Section/Signaling"></a><h2 id="signaling"><a href="#signaling">Signaling</a></h2><div class="section-content"><p>Unfortunately, WebRTC can't create connections without some sort of server in the middle. We call this the <strong>signal channel</strong> or <strong>signaling service</strong>. It's any sort of channel of communication to exchange information before setting up a connection, whether by email, postcard, or a carrier pigeon. It's up to you.</p>
<p>The information we need to exchange is the Offer and Answer which just contains the <a href="https://developer.mozilla.org/en-US/docs/Glossary/SDP">SDP</a> mentioned below.</p>
<p>Peer A who will be the initiator of the connection, will create an Offer. They will then send this offer to Peer B using the chosen signal channel. Peer B will receive the Offer from the signal channel and create an Answer. They will then send this back to Peer A along the signal channel.</p></div></section><section aria-labelledby="session_descriptions"><h3 id="session_descriptions"><a href="#session_descriptions">Session descriptions</a></h3><div class="section-content"><p>The configuration of an endpoint on a WebRTC connection is called a <strong>session description</strong>. The description includes information about the kind of media being sent, its format, the transfer protocol being used, the endpoint's IP address and port, and other information needed to describe a media transfer endpoint. This information is exchanged and stored using <strong>Session Description Protocol</strong> (<a href="https://developer.mozilla.org/en-US/docs/Glossary/SDP">SDP</a>); if you want details on the format of SDP data, you can find it in <a href="https://datatracker.ietf.org/doc/html/rfc2327" class="external" target="_blank">RFC 2327</a>.</p>
<p>When a user starts a WebRTC call to another user, a special description is created called an <strong>offer</strong>. This description includes all the information about the caller's proposed configuration for the call. The recipient then responds with an <strong>answer</strong>, which is a description of their end of the call. In this way, both devices share with one another the information needed in order to exchange media data. This exchange is handled using Interactive Connectivity Establishment (<a href="https://developer.mozilla.org/en-US/docs/Glossary/ICE">ICE</a>), a protocol which lets two devices use an intermediary to exchange offers and answers even if the two devices are separated by Network Address Translation (<a href="https://developer.mozilla.org/en-US/docs/Glossary/NAT">NAT</a>).</p>
<p>Each peer, then, keeps two descriptions on hand: the <strong>local description</strong>, describing itself, and the <strong>remote description</strong>, describing the other end of the call.</p>
<p>The offer/answer process is performed both when a call is first established, but also any time the call's format or other configuration needs to change. Regardless of whether it's a new call, or reconfiguring an existing one, these are the basic steps which must occur to exchange the offer and answer, leaving out the ICE layer for the moment:</p>
<ol>
  <li>The caller captures local Media via <a href="../MediaDevices/getUserMedia.html"><code>MediaDevices.getUserMedia</code></a></li>
  <li>The caller creates <code>RTCPeerConnection</code> and calls <a href="../RTCPeerConnection/addTrack.html"><code>RTCPeerConnection.addTrack()</code></a> (Since <code>addStream</code> is deprecating)</li>
  <li>The caller calls <a href="../RTCPeerConnection/createOffer.html"><code>RTCPeerConnection.createOffer()</code></a> to create an offer.</li>
  <li>The caller calls <a href="../RTCPeerConnection/setLocalDescription.html"><code>RTCPeerConnection.setLocalDescription()</code></a> to set that offer as the <em>local description</em> (that is, the description of the local end of the connection).</li>
  <li>After setLocalDescription(), the caller asks STUN servers to generate the ice candidates</li>
  <li>The caller uses the signaling server to transmit the offer to the intended receiver of the call.</li>
  <li>The recipient receives the offer and calls <a href="../RTCPeerConnection/setRemoteDescription.html"><code>RTCPeerConnection.setRemoteDescription()</code></a> to record it as the <em>remote description</em> (the description of the other end of the connection).</li>
  <li>The recipient does any setup it needs to do for its end of the call: capture its local media, and attach each media tracks into the peer connection via <a href="../RTCPeerConnection/addTrack.html"><code>RTCPeerConnection.addTrack()</code></a></li>
  <li>The recipient then creates an answer by calling <a href="../RTCPeerConnection/createAnswer.html"><code>RTCPeerConnection.createAnswer()</code></a>.</li>
  <li>The recipient calls <a href="../RTCPeerConnection/setLocalDescription.html"><code>RTCPeerConnection.setLocalDescription()</code></a>, passing in the created answer, to set the answer as its local description. The recipient now knows the configuration of both ends of the connection.</li>
  <li>The recipient uses the signaling server to send the answer to the caller.</li>
  <li>The caller receives the answer.</li>
  <li>The caller calls <a href="../RTCPeerConnection/setRemoteDescription.html"><code>RTCPeerConnection.setRemoteDescription()</code></a> to set the answer as the remote description for its end of the call. It now knows the configuration of both peers. Media begins to flow as configured.</li>
</ol></div></section><section aria-labelledby="pending_and_current_descriptions"><h3 id="pending_and_current_descriptions"><a href="#pending_and_current_descriptions">Pending and current descriptions</a></h3><div class="section-content"><p>Taking one step deeper into the process, we find that <code>localDescription</code> and <code>remoteDescription</code>, the properties which return these two descriptions, aren't as simple as they look. Because during renegotiation, an offer might be rejected because it proposes an incompatible format, it's necessary that each endpoint have the ability to propose a new format but not actually switch to it until it's accepted by the other peer. For that reason, WebRTC uses <em>pending</em> and <em>current</em> descriptions.</p>
<p>The <strong>current description</strong> (which is returned by the <a href="../RTCPeerConnection/currentLocalDescription.html"><code>RTCPeerConnection.currentLocalDescription</code></a> and <a href="../RTCPeerConnection/currentRemoteDescription.html"><code>RTCPeerConnection.currentRemoteDescription</code></a> properties) represents the description currently in actual use by the connection. This is the most recent connection that both sides have fully agreed to use.</p>
<p>The <strong>pending description</strong> (returned by <a href="../RTCPeerConnection/pendingLocalDescription.html"><code>RTCPeerConnection.pendingLocalDescription</code></a> and <a href="../RTCPeerConnection/pendingRemoteDescription.html"><code>RTCPeerConnection.pendingRemoteDescription</code></a>) indicates a description which is currently under consideration following a call to <code>setLocalDescription()</code> or <code>setRemoteDescription()</code>, respectively.</p>
<p>When reading the description (returned by <a href="../RTCPeerConnection/localDescription.html"><code>RTCPeerConnection.localDescription</code></a> and <a href="../RTCPeerConnection/remoteDescription.html"><code>RTCPeerConnection.remoteDescription</code></a>), the returned value is the value of <code>pendingLocalDescription</code>/<code>pendingRemoteDescription</code> if there's a pending description (that is, the pending description isn't <code>null</code>); otherwise, the current description (<code>currentLocalDescription</code>/<code>currentRemoteDescription</code>) is returned.</p>
<p>When changing the description by calling <code>setLocalDescription()</code> or <code>setRemoteDescription()</code>, the specified description is set as the pending description, and the WebRTC layer begins to evaluate whether or not it's acceptable. Once the proposed description has been agreed upon, the value of <code>currentLocalDescription</code> or <code>currentRemoteDescription</code> is changed to the pending description, and the pending description is set to null again, indicating that there isn't a pending description.</p>
<div class="notecard note" id="sect2">
  <p><strong>Note:</strong> The <code>pendingLocalDescription</code> contains not just the offer or answer under consideration, but any local ICE candidates which have already been gathered since the offer or answer was created. Similarly, <code>pendingRemoteDescription</code> includes any remote ICE candidates which have been provided by calls to <a href="../RTCPeerConnection/addIceCandidate.html"><code>RTCPeerConnection.addIceCandidate()</code></a>.</p>
</div>
<p>See the individual articles on these properties and methods for more specifics, and <a href="https://developer.mozilla.org/en-US/docs/Web/Media/Formats/WebRTC_codecs">Codecs used by WebRTC</a> for information about codecs supported by WebRTC and which are compatible with which browsers. The codecs guide also offers guidance to help you choose the best codecs for your needs.</p></div></section><section aria-labelledby="ice_candidates"><a class="dashAnchor" name="//apple_ref/Section/ICE%20candidates"></a><h2 id="ice_candidates"><a href="#ice_candidates">ICE candidates</a></h2><div class="section-content"><p>As well as exchanging information about the media (discussed above in Offer/Answer and SDP), peers must exchange information about the network connection. This is known as an <strong>ICE candidate</strong> and details the available methods the peer is able to communicate (directly or through a TURN server). Typically, each peer will propose its best candidates first, making their way down the line toward their worse candidates. Ideally, candidates are UDP (since it's faster, and media streams are able to recover from interruptions relatively easily), but the ICE standard does allow TCP candidates as well.</p>
<div class="notecard note" id="sect3">
  <p><strong>Note:</strong> Generally, ICE candidates using TCP are only going to be used when UDP is not available or is restricted in ways that make it not suitable for media streaming. Not all browsers support ICE over TCP, however.</p>
</div>
<p>ICE allows candidates to represent connections over either <a href="https://developer.mozilla.org/en-US/docs/Glossary/TCP">TCP</a> or <a href="https://developer.mozilla.org/en-US/docs/Glossary/UDP">UDP</a>, with UDP generally being preferred (and being more widely supported). Each protocol supports a few types of candidate, with the candidate types defining how the data makes its way from peer to peer.</p></div></section><section aria-labelledby="udp_candidate_types"><h3 id="udp_candidate_types"><a href="#udp_candidate_types">UDP candidate types</a></h3><div class="section-content"><p>UDP candidates (candidates with their <a href="../RTCIceCandidate/protocol.html" title="protocol"><code>protocol</code></a> set to <code>udp</code>) can be one of these types:</p>
<dl>
  <dt id="host"><code>host</code></dt>
  <dd>
    <p>A host candidate is one for which its <a href="../RTCIceCandidate/address.html" title="ip"><code>ip</code></a> address is the actual, direct IP address of the remote peer.</p>
  </dd>
  <dt id="prflx"><code>prflx</code></dt>
  <dd>
    <p>A peer reflexive candidate is one whose IP address comes from a symmetric NAT between the two peers, usually as an additional candidate during trickle ICE (that is, additional candidate exchanges that occur after primary signaling but before the connection verification phase is finished).</p>
  </dd>
  <dt id="srflx"><code>srflx</code></dt>
  <dd>
    <p>A server reflexive candidate is generated by a STUN/TURN server; the connection's initiator requests a candidate from the STUN server, which forwards the request through the remote peer's NAT, which creates and returns a candidate whose IP address is local to the remote peer. The STUN server then replies to the initiator's request with a candidate whose IP address is unrelated to the remote peer.</p>
  </dd>
  <dt id="relay"><code>relay</code></dt>
  <dd>
    <p>A relay candidate is generated just like a server reflexive candidate (<code>"srflx"</code>), but using <a href="https://developer.mozilla.org/en-US/docs/Glossary/TURN">TURN</a> instead of <a href="https://developer.mozilla.org/en-US/docs/Glossary/STUN">STUN</a>.</p>
  </dd>
</dl></div></section><section aria-labelledby="tcp_candidate_types"><h3 id="tcp_candidate_types"><a href="#tcp_candidate_types">TCP candidate types</a></h3><div class="section-content"><p>TCP candidates (that is, candidates whose <a href="../RTCIceCandidate/protocol.html" title="protocol"><code>protocol</code></a> is <code>tcp</code>) can be of these types:</p>
<dl>
  <dt id="active"><code>active</code></dt>
  <dd>
    <p>The transport will try to open an outbound connection but won't receive incoming connection requests. This is the most common type, and the only one that most user agents will gather.</p>
  </dd>
  <dt id="passive"><code>passive</code></dt>
  <dd>
    <p>The transport will receive incoming connection attempts but won't attempt a connection itself.</p>
  </dd>
  <dt id="so"><code>so</code></dt>
  <dd>
    <p>The transport will try to simultaneously open a connection with its peer.</p>
  </dd>
</dl></div></section><section aria-labelledby="choosing_a_candidate_pair"><h3 id="choosing_a_candidate_pair"><a href="#choosing_a_candidate_pair">Choosing a candidate pair</a></h3><div class="section-content"><p>The ICE layer selects one of the two peers to serve as the <strong>controlling agent</strong>. This is the ICE agent which will make the final decision as to which candidate pair to use for the connection. The other peer is called the <strong>controlled agent</strong>. You can identify which one your end of the connection is by examining the value of <a href="../RTCIceTransport/role.html" title="RTCIceCandidate.transport.role"><code>RTCIceCandidate.transport.role</code></a>, although in general it doesn't matter which is which.</p>
<p>The controlling agent not only takes responsibility for making the final decision as to which candidate pair to use, but also for signaling that selection to the controlled agent by using STUN and an updated offer, if necessary. The controlled agent just waits to be told which candidate pair to use.</p>
<p>It's important to keep in mind that a single ICE session may result in the controlling agent choosing more than one candidate pair. Each time it does so and shares that information with the controlled agent, the two peers reconfigure their connection to use the new configuration described by the new candidate pair.</p>
<p>Once the ICE session is complete, the configuration that's currently in effect is the final one, unless an ICE reset occurs.</p>
<p>At the end of each generation of candidates, an end-of-candidates notification is sent in the form of an <a href="../RTCIceCandidate.html"><code>RTCIceCandidate</code></a> whose <a href="../RTCIceCandidate/candidate.html" title="candidate"><code>candidate</code></a> property is an empty string. This candidate should still be added to the connection using <a href="../RTCPeerConnection/addIceCandidate.html" title="addIceCandidate()"><code>addIceCandidate()</code></a> method, as usual, in order to deliver that notification to the remote peer.</p>
<p>When there are no more candidates at all to be expected during the current negotiation exchange, an end-of-candidates notification is sent by delivering a <a href="../RTCIceCandidate.html"><code>RTCIceCandidate</code></a> whose <a href="../RTCIceCandidate/candidate.html" title="candidate"><code>candidate</code></a> property is <code>null</code>. This message does <em>not</em> need to be sent to the remote peer. It's a legacy notification of a state which can be detected instead by watching for the <a href="../RTCPeerConnection/iceGatheringState.html" title="iceGatheringState"><code>iceGatheringState</code></a> to change to <code>complete</code>, by watching for the <a href="../RTCPeerConnection/icegatheringstatechange_event.html" title="icegatheringstatechange"><code>icegatheringstatechange</code></a> event.</p></div></section><section aria-labelledby="when_things_go_wrong"><a class="dashAnchor" name="//apple_ref/Section/When%20things%20go%20wrong"></a><h2 id="when_things_go_wrong"><a href="#when_things_go_wrong">When things go wrong</a></h2><div class="section-content"><p>During negotiation, there will be times when things just don't work out. For example, when renegotiating a connection—for example, to adapt to changing hardware or network configurations—it's possible that negotiation could reach a dead end, or some form of error might occur that prevents negotiation at all. There may be permissions issues or other problems as well, for that matter.</p></div></section><section aria-labelledby="ice_rollbacks"><h3 id="ice_rollbacks"><a href="#ice_rollbacks">ICE rollbacks</a></h3><div class="section-content"><p>When renegotiating a connection that's already active and a situation arises in which the negotiation fails, you don't really want to kill the already-running call. After all, you were most likely just trying to upgrade or downgrade the connection, or to otherwise make adaptations to an ongoing session. Aborting the call would be an excessive reaction in that situation.</p>
<p>Instead, you can initiate an <strong>ICE rollback</strong>. A rollback restores the SDP offer (and the connection configuration by extension) to the configuration it had the last time the connection's <a href="../RTCPeerConnection/signalingState.html" title="signalingState"><code>signalingState</code></a> was <code>stable</code>.</p>
<p>To programmatically initiate a rollback, send a description whose <a href="../RTCSessionDescription/type.html" title="type"><code>type</code></a> is <code>rollback</code>. Any other properties in the description object are ignored.</p>
<p>In addition, the ICE agent will automatically initiate a rollback when a peer that had previously created an offer receives an offer from the remote peer. In other words, if the local peer is in the state <code>have-local-offer</code>, indicating that the local peer had previously <em>sent</em> an offer, calling <code>setRemoteDescription()</code> with a <em>received</em> offer triggers rollback so that the negotiation switches from the remote peer being the caller to the local peer being the caller.</p></div></section><section aria-labelledby="ice_restarts"><h3 id="ice_restarts"><a href="#ice_restarts">ICE restarts</a></h3><div class="section-content"><p>Learn about the <a href="Session_lifetime.html#ice_restart">ICE restart</a> process.</p></div></section><section aria-labelledby="the_entire_exchange_in_a_complicated_diagram"><a class="dashAnchor" name="//apple_ref/Section/The%20entire%20exchange%20in%20a%20complicated%20diagram"></a><h2 id="the_entire_exchange_in_a_complicated_diagram"><a href="#the_entire_exchange_in_a_complicated_diagram">The entire exchange in a complicated diagram</a></h2><div class="section-content"><p><a href="https://hacks.mozilla.org/2013/07/webrtc-and-the-ocean-of-acronyms/" class="external" target="_blank"><img src="Connectivity/webrtc-complete-diagram.png" alt="A complete architectural diagram showing the whole WebRTC process." width="641" height="559" loading="lazy"></a></p></div></section><aside class="metadata"><div class="metadata-content-container"><div id="on-github" class="on-github"><h3>Found a content problem with this page?</h3><ul><li>Edit the page <a href="https://github.com/mdn/content/edit/main/files/en-us/web/api/webrtc_api/connectivity/index.md" title="This will take you to GitHub, where you'll need to sign in first." target="_blank" rel="noopener noreferrer">on GitHub</a>.</li><li>Report the <a href="https://github.com/mdn/content/issues/new?template=page-report.yml&amp;mdn-url=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FWebRTC_API%2FConnectivity&amp;metadata=%3C%21--+Do+not+make+changes+below+this+line+--%3E%0A%3Cdetails%3E%0A%3Csummary%3EPage+report+details%3C%2Fsummary%3E%0A%0A*+Folder%3A+%60en-us%2Fweb%2Fapi%2Fwebrtc_api%2Fconnectivity%60%0A*+MDN+URL%3A+https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FWebRTC_API%2FConnectivity%0A*+GitHub+URL%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fblob%2Fmain%2Ffiles%2Fen-us%2Fweb%2Fapi%2Fwebrtc_api%2Fconnectivity%2Findex.md%0A*+Last+commit%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fcommit%2Fe60194342c9666ad8a2e6e5e6c25705fe818bcde%0A*+Document+last+modified%3A+2023-01-16T17%3A27%3A46.000Z%0A%0A%3C%2Fdetails%3E" title="This will take you to GitHub to file a new issue." target="_blank" rel="noopener noreferrer">content issue</a>.</li><li>View the source <a href="https://github.com/mdn/content/blob/main/files/en-us/web/api/webrtc_api/connectivity/index.md?plain=1" title="Folder: en-us/web/api/webrtc_api/connectivity (Opens in a new tab)" target="_blank" rel="noopener noreferrer">on GitHub</a>.</li></ul>Want to get more involved? Learn<!-- --> <a href="https://github.com/mdn/content/blob/main/CONTRIBUTING.md" title="This will take you to our contribution guidelines on GitHub." target="_blank" rel="noopener noreferrer">how to contribute</a>.</div><p class="last-modified-date">This page was last modified on<!-- --> <time datetime="2023-01-16T17:27:46.000Z">Jan 16, 2023</time> by<!-- --> <a href="Connectivity/contributors.txt">MDN contributors</a>.</p></div></aside></article></main></div><footer id="nav-footer" class="page-footer"><div><a href="http://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Connectivity">WebRTC connectivity</a> by <a href="http://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Connectivity$history">Mozilla Contributors</a> is licensed under <a href="http://creativecommons.org/licenses/by-sa/2.5/">CC-BY-SA 2.5</a>.</div></footer></div></div><script type="application/json" id="hydration">{"doc":{"isMarkdown":true,"isTranslated":false,"isActive":true,"flaws":{},"title":"WebRTC connectivity","mdn_url":"/en-US/docs/Web/API/WebRTC_API/Connectivity","locale":"en-US","native":"English (US)","sidebarHTML":"<ol><li><strong><a href=\"/en-US/docs/Web/API/WebRTC_API\">WebRTC API</a></strong></li><li class=\"toggle\"><details open=\"\"><summary>Guides</summary><ol><li><a href=\"/en-US/docs/Web/API/WebRTC_API/Protocols\">Introduction to WebRTC protocols</a></li><li><em><a href=\"/en-US/docs/Web/API/WebRTC_API/Connectivity\" aria-current=\"page\">WebRTC connectivity</a></em></li><li><a href=\"/en-US/docs/Web/API/WebRTC_API/Session_lifetime\">Lifetime of a WebRTC session</a></li><li><a href=\"/en-US/docs/Web/API/WebRTC_API/Signaling_and_video_calling\">Signaling and video calling</a></li><li><a href=\"/en-US/docs/Web/API/WebRTC_API/Using_data_channels\">Using WebRTC data channels</a></li><li><a href=\"/en-US/docs/Web/API/WebRTC_API/Using_DTMF\">Using DTMF with WebRTC</a></li><li><a href=\"/en-US/docs/Web/API/WebRTC_API#interoperability\">WebRTC API</a></li><li><a href=\"/en-US/docs/Web/API/WebRTC_API/Simple_RTCDataChannel_sample\">A simple RTCDataChannel sample</a></li><li><a href=\"/en-US/docs/Web/API/WebRTC_API/Build_a_phone_with_peerjs\">Building an Internet-Connected Phone with PeerJS</a></li></ol></details></li><li class=\"toggle\"><details open=\"\"><summary>Interfaces</summary><ol><li><a href=\"/en-US/docs/Web/API/RTCPeerConnection\"><code>RTCPeerConnection</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCSessionDescription\"><code>RTCSessionDescription</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCIceCandidate\"><code>RTCIceCandidate</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCPeerConnectionIceEvent\"><code>RTCPeerConnectionIceEvent</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCPeerConnectionIceErrorEvent\"><code>RTCPeerConnectionIceErrorEvent</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCCertificate\"><code>RTCCertificate</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCRtpSender\"><code>RTCRtpSender</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCRtpReceiver\"><code>RTCRtpReceiver</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCRtpTransceiver\"><code>RTCRtpTransceiver</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCDtlsTransport\"><code>RTCDtlsTransport</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCIceTransport\"><code>RTCIceTransport</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCTrackEvent\"><code>RTCTrackEvent</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCSctpTransport\"><code>RTCSctpTransport</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCDataChannel\"><code>RTCDataChannel</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCDataChannelEvent\"><code>RTCDataChannelEvent</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCDTMFSender\"><code>RTCDTMFSender</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCDTMFToneChangeEvent\"><code>RTCDTMFToneChangeEvent</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCStatsReport\"><code>RTCStatsReport</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCErrorEvent\"><code>RTCErrorEvent</code></a></li></ol></details></li><li class=\"toggle\"><details open=\"\"><summary>Properties</summary><ol><li><a href=\"/en-US/docs/Web/API/Navigator/mediaDevices\"><code>Navigator.mediaDevices</code></a></li></ol></details></li><li class=\"toggle\"><details open=\"\"><summary>Methods</summary><ol><li><a href=\"/en-US/docs/Web/API/MediaDevices/getUserMedia\"><code>MediaDevices.getUserMedia()</code></a></li></ol></details></li><li class=\"toggle\"><details open=\"\"><summary>Events</summary><ol><li><a href=\"/en-US/docs/Web/API/RTCDTMFSender/tonechange_event\"><code>RTCDTMFSender</code>: <code>tonechange</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCDataChannel/bufferedamountlow_event\"><code>RTCDataChannel</code>: <code>bufferedamountlow</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCDataChannel/close_event\"><code>RTCDataChannel</code>: <code>close</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCDataChannel/closing_event\"><code>RTCDataChannel</code>: <code>closing</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCDataChannel/error_event\"><code>RTCDataChannel</code>: <code>error</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCDataChannel/message_event\"><code>RTCDataChannel</code>: <code>message</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCDataChannel/open_event\"><code>RTCDataChannel</code>: <code>open</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCDtlsTransport/error_event\"><code>RTCDtlsTransport</code>: <code>error</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCDtlsTransport/statechange_event\"><code>RTCDtlsTransport</code>: <code>statechange</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCIceTransport/error_event\"><code>RTCIceTransport</code>: <code>error</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCIceTransport/gatheringstatechange_event\"><code>RTCIceTransport</code>: <code>gatheringstatechange</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCIceTransport/selectedcandidatepairchange_event\"><code>RTCIceTransport</code>: <code>selectedcandidatepairchange</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCIceTransport/statechange_event\"><code>RTCIceTransport</code>: <code>statechange</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCPeerConnection/connectionstatechange_event\"><code>RTCPeerConnection</code>: <code>connectionstatechange</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCPeerConnection/datachannel_event\"><code>RTCPeerConnection</code>: <code>datachannel</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCPeerConnection/icecandidate_event\"><code>RTCPeerConnection</code>: <code>icecandidate</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCPeerConnection/icecandidateerror_event\"><code>RTCPeerConnection</code>: <code>icecandidateerror</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCPeerConnection/iceconnectionstatechange_event\"><code>RTCPeerConnection</code>: <code>iceconnectionstatechange</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCPeerConnection/icegatheringstatechange_event\"><code>RTCPeerConnection</code>: <code>icegatheringstatechange</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCPeerConnection/negotiationneeded_event\"><code>RTCPeerConnection</code>: <code>negotiationneeded</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCPeerConnection/signalingstatechange_event\"><code>RTCPeerConnection</code>: <code>signalingstatechange</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCPeerConnection/track_event\"><code>RTCPeerConnection</code>: <code>track</code></a></li><li><a href=\"/en-US/docs/Web/API/RTCSctpTransport/error_event\"><code>RTCSctpTransport</code>: <code>error</code></a></li></ol></details></li></ol>","body":[{"type":"prose","value":{"id":null,"title":null,"isH3":false,"content":"<p>This article describes how the various WebRTC-related protocols interact with one another in order to create a connection and transfer data and/or media among peers.</p>\n<div class=\"notecard note\" id=\"sect1\">\n  <p><strong>Note:</strong> This page needs heavy rewriting for structural integrity and content completeness. Lots of info here is good but the organization is a mess since this is sort of a dumping ground right now.</p>\n</div>"}},{"type":"prose","value":{"id":"signaling","title":"Signaling","isH3":false,"content":"<p>Unfortunately, WebRTC can't create connections without some sort of server in the middle. We call this the <strong>signal channel</strong> or <strong>signaling service</strong>. It's any sort of channel of communication to exchange information before setting up a connection, whether by email, postcard, or a carrier pigeon. It's up to you.</p>\n<p>The information we need to exchange is the Offer and Answer which just contains the <a href=\"/en-US/docs/Glossary/SDP\">SDP</a> mentioned below.</p>\n<p>Peer A who will be the initiator of the connection, will create an Offer. They will then send this offer to Peer B using the chosen signal channel. Peer B will receive the Offer from the signal channel and create an Answer. They will then send this back to Peer A along the signal channel.</p>"}},{"type":"prose","value":{"id":"session_descriptions","title":"Session descriptions","isH3":true,"content":"<p>The configuration of an endpoint on a WebRTC connection is called a <strong>session description</strong>. The description includes information about the kind of media being sent, its format, the transfer protocol being used, the endpoint's IP address and port, and other information needed to describe a media transfer endpoint. This information is exchanged and stored using <strong>Session Description Protocol</strong> (<a href=\"/en-US/docs/Glossary/SDP\">SDP</a>); if you want details on the format of SDP data, you can find it in <a href=\"https://datatracker.ietf.org/doc/html/rfc2327\" class=\"external\" target=\"_blank\">RFC 2327</a>.</p>\n<p>When a user starts a WebRTC call to another user, a special description is created called an <strong>offer</strong>. This description includes all the information about the caller's proposed configuration for the call. The recipient then responds with an <strong>answer</strong>, which is a description of their end of the call. In this way, both devices share with one another the information needed in order to exchange media data. This exchange is handled using Interactive Connectivity Establishment (<a href=\"/en-US/docs/Glossary/ICE\">ICE</a>), a protocol which lets two devices use an intermediary to exchange offers and answers even if the two devices are separated by Network Address Translation (<a href=\"/en-US/docs/Glossary/NAT\">NAT</a>).</p>\n<p>Each peer, then, keeps two descriptions on hand: the <strong>local description</strong>, describing itself, and the <strong>remote description</strong>, describing the other end of the call.</p>\n<p>The offer/answer process is performed both when a call is first established, but also any time the call's format or other configuration needs to change. Regardless of whether it's a new call, or reconfiguring an existing one, these are the basic steps which must occur to exchange the offer and answer, leaving out the ICE layer for the moment:</p>\n<ol>\n  <li>The caller captures local Media via <a href=\"/en-US/docs/Web/API/MediaDevices/getUserMedia\"><code>MediaDevices.getUserMedia</code></a></li>\n  <li>The caller creates <code>RTCPeerConnection</code> and calls <a href=\"/en-US/docs/Web/API/RTCPeerConnection/addTrack\"><code>RTCPeerConnection.addTrack()</code></a> (Since <code>addStream</code> is deprecating)</li>\n  <li>The caller calls <a href=\"/en-US/docs/Web/API/RTCPeerConnection/createOffer\"><code>RTCPeerConnection.createOffer()</code></a> to create an offer.</li>\n  <li>The caller calls <a href=\"/en-US/docs/Web/API/RTCPeerConnection/setLocalDescription\"><code>RTCPeerConnection.setLocalDescription()</code></a> to set that offer as the <em>local description</em> (that is, the description of the local end of the connection).</li>\n  <li>After setLocalDescription(), the caller asks STUN servers to generate the ice candidates</li>\n  <li>The caller uses the signaling server to transmit the offer to the intended receiver of the call.</li>\n  <li>The recipient receives the offer and calls <a href=\"/en-US/docs/Web/API/RTCPeerConnection/setRemoteDescription\"><code>RTCPeerConnection.setRemoteDescription()</code></a> to record it as the <em>remote description</em> (the description of the other end of the connection).</li>\n  <li>The recipient does any setup it needs to do for its end of the call: capture its local media, and attach each media tracks into the peer connection via <a href=\"/en-US/docs/Web/API/RTCPeerConnection/addTrack\"><code>RTCPeerConnection.addTrack()</code></a></li>\n  <li>The recipient then creates an answer by calling <a href=\"/en-US/docs/Web/API/RTCPeerConnection/createAnswer\"><code>RTCPeerConnection.createAnswer()</code></a>.</li>\n  <li>The recipient calls <a href=\"/en-US/docs/Web/API/RTCPeerConnection/setLocalDescription\"><code>RTCPeerConnection.setLocalDescription()</code></a>, passing in the created answer, to set the answer as its local description. The recipient now knows the configuration of both ends of the connection.</li>\n  <li>The recipient uses the signaling server to send the answer to the caller.</li>\n  <li>The caller receives the answer.</li>\n  <li>The caller calls <a href=\"/en-US/docs/Web/API/RTCPeerConnection/setRemoteDescription\"><code>RTCPeerConnection.setRemoteDescription()</code></a> to set the answer as the remote description for its end of the call. It now knows the configuration of both peers. Media begins to flow as configured.</li>\n</ol>"}},{"type":"prose","value":{"id":"pending_and_current_descriptions","title":"Pending and current descriptions","isH3":true,"content":"<p>Taking one step deeper into the process, we find that <code>localDescription</code> and <code>remoteDescription</code>, the properties which return these two descriptions, aren't as simple as they look. Because during renegotiation, an offer might be rejected because it proposes an incompatible format, it's necessary that each endpoint have the ability to propose a new format but not actually switch to it until it's accepted by the other peer. For that reason, WebRTC uses <em>pending</em> and <em>current</em> descriptions.</p>\n<p>The <strong>current description</strong> (which is returned by the <a href=\"/en-US/docs/Web/API/RTCPeerConnection/currentLocalDescription\"><code>RTCPeerConnection.currentLocalDescription</code></a> and <a href=\"/en-US/docs/Web/API/RTCPeerConnection/currentRemoteDescription\"><code>RTCPeerConnection.currentRemoteDescription</code></a> properties) represents the description currently in actual use by the connection. This is the most recent connection that both sides have fully agreed to use.</p>\n<p>The <strong>pending description</strong> (returned by <a href=\"/en-US/docs/Web/API/RTCPeerConnection/pendingLocalDescription\"><code>RTCPeerConnection.pendingLocalDescription</code></a> and <a href=\"/en-US/docs/Web/API/RTCPeerConnection/pendingRemoteDescription\"><code>RTCPeerConnection.pendingRemoteDescription</code></a>) indicates a description which is currently under consideration following a call to <code>setLocalDescription()</code> or <code>setRemoteDescription()</code>, respectively.</p>\n<p>When reading the description (returned by <a href=\"/en-US/docs/Web/API/RTCPeerConnection/localDescription\"><code>RTCPeerConnection.localDescription</code></a> and <a href=\"/en-US/docs/Web/API/RTCPeerConnection/remoteDescription\"><code>RTCPeerConnection.remoteDescription</code></a>), the returned value is the value of <code>pendingLocalDescription</code>/<code>pendingRemoteDescription</code> if there's a pending description (that is, the pending description isn't <code>null</code>); otherwise, the current description (<code>currentLocalDescription</code>/<code>currentRemoteDescription</code>) is returned.</p>\n<p>When changing the description by calling <code>setLocalDescription()</code> or <code>setRemoteDescription()</code>, the specified description is set as the pending description, and the WebRTC layer begins to evaluate whether or not it's acceptable. Once the proposed description has been agreed upon, the value of <code>currentLocalDescription</code> or <code>currentRemoteDescription</code> is changed to the pending description, and the pending description is set to null again, indicating that there isn't a pending description.</p>\n<div class=\"notecard note\" id=\"sect2\">\n  <p><strong>Note:</strong> The <code>pendingLocalDescription</code> contains not just the offer or answer under consideration, but any local ICE candidates which have already been gathered since the offer or answer was created. Similarly, <code>pendingRemoteDescription</code> includes any remote ICE candidates which have been provided by calls to <a href=\"/en-US/docs/Web/API/RTCPeerConnection/addIceCandidate\"><code>RTCPeerConnection.addIceCandidate()</code></a>.</p>\n</div>\n<p>See the individual articles on these properties and methods for more specifics, and <a href=\"/en-US/docs/Web/Media/Formats/WebRTC_codecs\">Codecs used by WebRTC</a> for information about codecs supported by WebRTC and which are compatible with which browsers. The codecs guide also offers guidance to help you choose the best codecs for your needs.</p>"}},{"type":"prose","value":{"id":"ice_candidates","title":"ICE candidates","isH3":false,"content":"<p>As well as exchanging information about the media (discussed above in Offer/Answer and SDP), peers must exchange information about the network connection. This is known as an <strong>ICE candidate</strong> and details the available methods the peer is able to communicate (directly or through a TURN server). Typically, each peer will propose its best candidates first, making their way down the line toward their worse candidates. Ideally, candidates are UDP (since it's faster, and media streams are able to recover from interruptions relatively easily), but the ICE standard does allow TCP candidates as well.</p>\n<div class=\"notecard note\" id=\"sect3\">\n  <p><strong>Note:</strong> Generally, ICE candidates using TCP are only going to be used when UDP is not available or is restricted in ways that make it not suitable for media streaming. Not all browsers support ICE over TCP, however.</p>\n</div>\n<p>ICE allows candidates to represent connections over either <a href=\"/en-US/docs/Glossary/TCP\">TCP</a> or <a href=\"/en-US/docs/Glossary/UDP\">UDP</a>, with UDP generally being preferred (and being more widely supported). Each protocol supports a few types of candidate, with the candidate types defining how the data makes its way from peer to peer.</p>"}},{"type":"prose","value":{"id":"udp_candidate_types","title":"UDP candidate types","isH3":true,"content":"<p>UDP candidates (candidates with their <a href=\"/en-US/docs/Web/API/RTCIceCandidate/protocol\" title=\"protocol\"><code>protocol</code></a> set to <code>udp</code>) can be one of these types:</p>\n<dl>\n  <dt id=\"host\"><code>host</code></dt>\n  <dd>\n    <p>A host candidate is one for which its <a href=\"/en-US/docs/Web/API/RTCIceCandidate/address\" title=\"ip\"><code>ip</code></a> address is the actual, direct IP address of the remote peer.</p>\n  </dd>\n  <dt id=\"prflx\"><code>prflx</code></dt>\n  <dd>\n    <p>A peer reflexive candidate is one whose IP address comes from a symmetric NAT between the two peers, usually as an additional candidate during trickle ICE (that is, additional candidate exchanges that occur after primary signaling but before the connection verification phase is finished).</p>\n  </dd>\n  <dt id=\"srflx\"><code>srflx</code></dt>\n  <dd>\n    <p>A server reflexive candidate is generated by a STUN/TURN server; the connection's initiator requests a candidate from the STUN server, which forwards the request through the remote peer's NAT, which creates and returns a candidate whose IP address is local to the remote peer. The STUN server then replies to the initiator's request with a candidate whose IP address is unrelated to the remote peer.</p>\n  </dd>\n  <dt id=\"relay\"><code>relay</code></dt>\n  <dd>\n    <p>A relay candidate is generated just like a server reflexive candidate (<code>\"srflx\"</code>), but using <a href=\"/en-US/docs/Glossary/TURN\">TURN</a> instead of <a href=\"/en-US/docs/Glossary/STUN\">STUN</a>.</p>\n  </dd>\n</dl>"}},{"type":"prose","value":{"id":"tcp_candidate_types","title":"TCP candidate types","isH3":true,"content":"<p>TCP candidates (that is, candidates whose <a href=\"/en-US/docs/Web/API/RTCIceCandidate/protocol\" title=\"protocol\"><code>protocol</code></a> is <code>tcp</code>) can be of these types:</p>\n<dl>\n  <dt id=\"active\"><code>active</code></dt>\n  <dd>\n    <p>The transport will try to open an outbound connection but won't receive incoming connection requests. This is the most common type, and the only one that most user agents will gather.</p>\n  </dd>\n  <dt id=\"passive\"><code>passive</code></dt>\n  <dd>\n    <p>The transport will receive incoming connection attempts but won't attempt a connection itself.</p>\n  </dd>\n  <dt id=\"so\"><code>so</code></dt>\n  <dd>\n    <p>The transport will try to simultaneously open a connection with its peer.</p>\n  </dd>\n</dl>"}},{"type":"prose","value":{"id":"choosing_a_candidate_pair","title":"Choosing a candidate pair","isH3":true,"content":"<p>The ICE layer selects one of the two peers to serve as the <strong>controlling agent</strong>. This is the ICE agent which will make the final decision as to which candidate pair to use for the connection. The other peer is called the <strong>controlled agent</strong>. You can identify which one your end of the connection is by examining the value of <a href=\"/en-US/docs/Web/API/RTCIceTransport/role\" title=\"RTCIceCandidate.transport.role\"><code>RTCIceCandidate.transport.role</code></a>, although in general it doesn't matter which is which.</p>\n<p>The controlling agent not only takes responsibility for making the final decision as to which candidate pair to use, but also for signaling that selection to the controlled agent by using STUN and an updated offer, if necessary. The controlled agent just waits to be told which candidate pair to use.</p>\n<p>It's important to keep in mind that a single ICE session may result in the controlling agent choosing more than one candidate pair. Each time it does so and shares that information with the controlled agent, the two peers reconfigure their connection to use the new configuration described by the new candidate pair.</p>\n<p>Once the ICE session is complete, the configuration that's currently in effect is the final one, unless an ICE reset occurs.</p>\n<p>At the end of each generation of candidates, an end-of-candidates notification is sent in the form of an <a href=\"/en-US/docs/Web/API/RTCIceCandidate\"><code>RTCIceCandidate</code></a> whose <a href=\"/en-US/docs/Web/API/RTCIceCandidate/candidate\" title=\"candidate\"><code>candidate</code></a> property is an empty string. This candidate should still be added to the connection using <a href=\"/en-US/docs/Web/API/RTCPeerConnection/addIceCandidate\" title=\"addIceCandidate()\"><code>addIceCandidate()</code></a> method, as usual, in order to deliver that notification to the remote peer.</p>\n<p>When there are no more candidates at all to be expected during the current negotiation exchange, an end-of-candidates notification is sent by delivering a <a href=\"/en-US/docs/Web/API/RTCIceCandidate\"><code>RTCIceCandidate</code></a> whose <a href=\"/en-US/docs/Web/API/RTCIceCandidate/candidate\" title=\"candidate\"><code>candidate</code></a> property is <code>null</code>. This message does <em>not</em> need to be sent to the remote peer. It's a legacy notification of a state which can be detected instead by watching for the <a href=\"/en-US/docs/Web/API/RTCPeerConnection/iceGatheringState\" title=\"iceGatheringState\"><code>iceGatheringState</code></a> to change to <code>complete</code>, by watching for the <a href=\"/en-US/docs/Web/API/RTCPeerConnection/icegatheringstatechange_event\" title=\"icegatheringstatechange\"><code>icegatheringstatechange</code></a> event.</p>"}},{"type":"prose","value":{"id":"when_things_go_wrong","title":"When things go wrong","isH3":false,"content":"<p>During negotiation, there will be times when things just don't work out. For example, when renegotiating a connection—for example, to adapt to changing hardware or network configurations—it's possible that negotiation could reach a dead end, or some form of error might occur that prevents negotiation at all. There may be permissions issues or other problems as well, for that matter.</p>"}},{"type":"prose","value":{"id":"ice_rollbacks","title":"ICE rollbacks","isH3":true,"content":"<p>When renegotiating a connection that's already active and a situation arises in which the negotiation fails, you don't really want to kill the already-running call. After all, you were most likely just trying to upgrade or downgrade the connection, or to otherwise make adaptations to an ongoing session. Aborting the call would be an excessive reaction in that situation.</p>\n<p>Instead, you can initiate an <strong>ICE rollback</strong>. A rollback restores the SDP offer (and the connection configuration by extension) to the configuration it had the last time the connection's <a href=\"/en-US/docs/Web/API/RTCPeerConnection/signalingState\" title=\"signalingState\"><code>signalingState</code></a> was <code>stable</code>.</p>\n<p>To programmatically initiate a rollback, send a description whose <a href=\"/en-US/docs/Web/API/RTCSessionDescription/type\" title=\"type\"><code>type</code></a> is <code>rollback</code>. Any other properties in the description object are ignored.</p>\n<p>In addition, the ICE agent will automatically initiate a rollback when a peer that had previously created an offer receives an offer from the remote peer. In other words, if the local peer is in the state <code>have-local-offer</code>, indicating that the local peer had previously <em>sent</em> an offer, calling <code>setRemoteDescription()</code> with a <em>received</em> offer triggers rollback so that the negotiation switches from the remote peer being the caller to the local peer being the caller.</p>"}},{"type":"prose","value":{"id":"ice_restarts","title":"ICE restarts","isH3":true,"content":"<p>Learn about the <a href=\"/en-US/docs/Web/API/WebRTC_API/Session_lifetime#ice_restart\">ICE restart</a> process.</p>"}},{"type":"prose","value":{"id":"the_entire_exchange_in_a_complicated_diagram","title":"The entire exchange in a complicated diagram","isH3":false,"content":"<p><a href=\"https://hacks.mozilla.org/2013/07/webrtc-and-the-ocean-of-acronyms/\" class=\"external\" target=\"_blank\"><img src=\"/en-US/docs/Web/API/WebRTC_API/Connectivity/webrtc-complete-diagram.png\" alt=\"A complete architectural diagram showing the whole WebRTC process.\" width=\"641\" height=\"559\" loading=\"lazy\"></a></p>"}}],"toc":[{"text":"Signaling","id":"signaling"},{"text":"ICE candidates","id":"ice_candidates"},{"text":"When things go wrong","id":"when_things_go_wrong"},{"text":"The entire exchange in a complicated diagram","id":"the_entire_exchange_in_a_complicated_diagram"}],"summary":"This article describes how the various WebRTC-related protocols interact with one another in order to create a connection and transfer data and/or media among peers.","popularity":0,"modified":"2023-01-16T17:27:46.000Z","other_translations":[{"title":"Introduction à l'architecture WebRTC","locale":"fr","native":"Français"},{"title":"WebRTC 接続","locale":"ja","native":"日本語"},{"title":"WebRTC подключение","locale":"ru","native":"Русский"},{"title":"WebRTC connectivity","locale":"zh-CN","native":"中文 (简体)"}],"source":{"folder":"en-us/web/api/webrtc_api/connectivity","github_url":"https://github.com/mdn/content/blob/main/files/en-us/web/api/webrtc_api/connectivity/index.md","last_commit_url":"https://github.com/mdn/content/commit/e60194342c9666ad8a2e6e5e6c25705fe818bcde","filename":"index.md"},"short_title":"WebRTC connectivity","parents":[{"uri":"/en-US/docs/Web","title":"References"},{"uri":"/en-US/docs/Web/API","title":"Web APIs"},{"uri":"/en-US/docs/Web/API/WebRTC_API","title":"WebRTC API"},{"uri":"/en-US/docs/Web/API/WebRTC_API/Connectivity","title":"WebRTC connectivity"}],"pageTitle":"WebRTC connectivity - Web APIs | MDN","noIndexing":false}}</script>
<!-- Mirrored from developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Connectivity by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 14 Feb 2023 04:49:47 GMT -->
</body></html>